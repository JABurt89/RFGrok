Below are detailed instructions for an AI coder to implement features specified in the Product Requirements Document (PRD) that are currently missing from the workout web app. These instructions assume the app is in an early development stage with partial functionality and focus on bridging the gap to fully align with the PRD. Each section addresses a specific feature area, providing actionable technical steps for implementation.

---

## Instructions for Implementing Missing Features

### 1. User Authentication
**Required Features**:
- Email and password-based signup and login (no complexity requirements).
- Password recovery via email with a reset link valid for 24 hours.
- Data syncing across devices on login.
- Basic security measures (e.g., hashed passwords).

**Implementation Steps**:
1. **Backend Setup**:
   - Use Firebase Authentication or set up a custom Node.js/Express server with a database like PostgreSQL.
   - Create REST API endpoints:
     - `POST /signup`: Register a new user.
     - `POST /login`: Authenticate a user.
     - `POST /reset-password`: Send a reset link to the user's email.
   - Use a library like `nodemailer` for email sending if custom-built.
2. **Frontend Integration**:
   - Build signup and login forms with email and password fields using HTML/CSS/JavaScript (or a framework like React).
   - Add a "Forgot Password?" link that triggers an email with a reset token (valid for 24 hours, stored in the database with an expiration timestamp).
3. **Data Syncing**:
   - Store user data (e.g., exercises, workout logs) in a cloud database tied to the user’s ID.
   - On login, fetch cloud data and merge with local data (if any), resolving conflicts by prompting the user to choose the preferred version.
4. **Security**:
   - Hash passwords with `bcrypt` before storing them.
   - Validate inputs to prevent SQL injection or XSS (e.g., sanitize email fields).

---

### 2. Exercise Management
**Required Features**:
- Create exercises with attributes: units (kg/lb), predefined or custom equipment, increment, and starting weight.
- Edit and archive exercises (archived exercises are restorable and displayed as "[Archived] ExerciseName" in logs).
- Support multiple instances of the same exercise with different progression schemes.

**Implementation Steps**:
1. **Database Schema**:
   - Create an `exercises` table:
     ```sql
     CREATE TABLE exercises (
       id SERIAL PRIMARY KEY,
       user_id INT REFERENCES users(id),
       name VARCHAR(255),
       units ENUM('kg', 'lb'),
       equipment_name VARCHAR(255),
       starting_weight FLOAT,
       increment FLOAT,
       archived BOOLEAN DEFAULT FALSE
     );
     ```
2. **UI for Exercise Creation**:
   - Build a form with fields: name, units (dropdown), equipment (dropdown for predefined options like "Barbell" or text input for custom), starting weight, and increment.
   - Auto-set starting weight for predefined equipment (e.g., 20kg for Barbell, converted to lb if units are lb using 1kg = 2.20462lb).
3. **Editing and Archiving**:
   - Add "Edit" and "Archive" buttons next to each exercise in a list view.
   - On archive, update `archived = true` and modify display logic to prepend "[Archived]" to the name in logs.
   - Allow restoring archived exercises via a "Restore" button.
4. **Multiple Instances**:
   - Store progression scheme details with workout day instances rather than the exercise itself, allowing the same exercise name to have different schemes.

---

### 3. Workout Day Construction
**Required Features**:
- Create workout days with drag-and-drop exercise ordering.
- Assign one progression scheme per exercise instance.
- Set rest times between sets and exercises (locked once workout starts).

**Implementation Steps**:
1. **Drag-and-Drop UI**:
   - Use a library like `react-dnd` (for React) or `SortableJS` to enable drag-and-drop functionality for ordering exercises in a workout day.
   - Update the order in the database or local state when dropped.
2. **Scheme Assignment**:
   - Add a dropdown with options: STS, Double Progression, RPT Top-Set Dependent, RPT Individual Progression when adding an exercise to a workout day.
   - Save the selected scheme with the exercise instance in the `workout_exercises` table.
3. **Rest Times**:
   - Include numeric input fields for rest times (in seconds) for sets and exercises when constructing the workout day.
   - Disable editing of these fields once the workout starts (e.g., toggle to read-only mode in the UI).

---

### 4. Progression Schemes
**Required Features**:
- Implement four schemes: STS, Double Progression, RPT Top-Set Dependent, and RPT Individual Progression.
- Calculate 1RM and suggest future workouts per scheme specifications.

**Implementation Steps**:
1. **STS (Set-Training-System)**:
   - Calculate 1RM:
     - Without extra set: `1RM = W × (1 + 0.025 × R) × (1 + 0.025 × (S - 1))`
     - With extra set to failure: 
       ```javascript
       const C = W * (1 + 0.025 * R) * (1 + 0.025 * (S - 1));
       const F = W * (1 + 0.025 * R) * (1 + 0.025 * S);
       const failedRep = /* reps from extra set */;
       const 1RM = C + (failedRep / R) * (F - C);
       ```
   - Generate 10 suggestions by iterating through possible sets, reps, and weights, selecting those with the smallest 1RM increases.
2. **Double Progression**:
   - Track reps across sets; if all sets hit the maximum reps, increase weight by the increment for the next workout.
3. **RPT Top-Set Dependent**:
   - Allow user-defined back-off percentages (e.g., 80% of top-set weight).
   - Increase top-set weight when target reps are met, adjusting back-off sets proportionally.
4. **RPT Individual Progression**:
   - Define rep ranges: decrease weight if reps < 6, maintain if 6-7, increase if =8.
   - Adjust weight by the increment based on the last set’s reps.

---

### 5. Workout Suggestions
**Required Features**:
- For STS, generate 10 suggestions with the smallest 1RM increases.
- Handle edge cases (no valid suggestions) by prompting manual entry.
- Use starting weight for first-time workouts.

**Implementation Steps**:
1. **STS Suggestion Logic**:
   - Write a function to calculate 1RM for various combinations of sets (1-5), reps (1-12), and weights (current ± increments).
   - Filter combinations where 1RM > last logged 1RM, sort by increase, and take the top 10.
   - If no valid combinations exist, display a modal prompting manual input.
2. **First-Time Workouts**:
   - Check if the exercise has prior logs; if not, default to the `starting_weight` from the exercise definition.

---

### 6. Workout Logging
**Required Features**:
- Log reps, weight, and timestamps per set.
- For STS, prompt for an extra set to failure after the last planned set.
- Support offline logging with syncing.

**Implementation Steps**:
1. **Logging UI**:
   - Create a workout interface with input fields for reps and weight per set.
   - Automatically record timestamps when a set is marked complete (e.g., `new Date().toISOString()`).
2. **STS Extra Set**:
   - After the last set, show a prompt: "Attempt an extra set to failure?"
   - If yes, wait for rest timer expiration, then collect reps and calculate 1RM using the extra-set formula.
3. **Offline Support**:
   - Use `IndexedDB` or `localStorage` to store logs locally when offline.
   - Implement a sync function to upload local data to the server when online, merging with existing cloud data.

---

### 7. Rest Timers
**Required Features**:
- Auto-start when a set is marked complete.
- Reset if the next set is completed before expiration.
- Play a single chime when expired.

**Implementation Steps**:
1. **Timer Logic**:
   - Use JavaScript’s `setTimeout`:
     ```javascript
     let timer;
     function startRestTimer(seconds) {
       clearTimeout(timer);
       timer = setTimeout(() => playChime(), seconds * 1000);
     }
     // Call startRestTimer when a set is completed
     ```
   - Reset the timer (`clearTimeout`) if the next set is completed early.
2. **Chime**:
   - Play an audio file:
     ```javascript
     function playChime() {
       new Audio('path/to/chime.mp3').play();
     }
     ```

---

### 8. Workout History
**Required Features**:
- Store detailed workout data (including calculated rest times).
- Export all data as a unified CSV.
- Handle incomplete workouts (save, discard, or resume).

**Implementation Steps**:
1. **Data Storage**:
   - Store logs in a `workout_logs` table with fields for exercise, sets, reps, weights, timestamps, etc.
   - Calculate rest times by subtracting consecutive set timestamps.
2. **CSV Export**:
   - Create a function to generate CSV:
     ```javascript
     function exportToCSV(logs) {
       const headers = 'Date,Exercise,Sets,Reps,Weight,1RM\n';
       const rows = logs.map(log => `${log.date},${log.exercise},${log.sets},${log.reps},${log.weight},${log.oneRM}`).join('\n');
       const csv = headers + rows;
       const blob = new Blob([csv], { type: 'text/csv' });
       const url = window.URL.createObjectURL(blob);
       const a = document.createElement('a');
       a.href = url;
       a.download = 'workout_history.csv';
       a.click();
     }
     ```
3. **Incomplete Workouts**:
   - On exit, prompt with options: "Save and Exit," "Discard," or "Resume Later."
   - Flag incomplete workouts in the database and allow resuming from the last set.

---

### 9. User Profiles
**Required Features**:
- Editable fields: age, weight, fitness goals.
- Changes do not affect past data or progression calculations.

**Implementation Steps**:
1. **Profile UI**:
   - Add a profile page with form inputs for age, weight, and goals (e.g., dropdown or text).
2. **Data Handling**:
   - Store profile data in a `users` table, separate from workout logs.
   - Use historical data (e.g., weight at the time of the workout) for progression calculations, not current profile values.

---

### 10. User Interface (UI)
**Required Features**:
- Mobile mode with a collapsible sidebar.
- Default dark mode with a light mode toggle.

**Implementation Steps**:
1. **Mobile Mode**:
   - Use CSS media queries:
     ```css
     @media (max-width: 768px) {
       .sidebar { width: 0; overflow: hidden; }
       .sidebar.expanded { width: 200px; }
     }
     ```
   - Add a toggle button:
     ```javascript
     document.querySelector('.toggle-btn').addEventListener('click', () => {
       document.querySelector('.sidebar').classList.toggle('expanded');
     });
     ```
2. **Dark Mode**:
   - Define CSS variables:
     ```css
     :root {
       --bg-color: #1a1a1a;
       --text-color: #ffffff;
     }
     [data-theme="light"] {
       --bg-color: #ffffff;
       --text-color: #000000;
     }
     body { background: var(--bg-color); color: var(--text-color); }
     ```
   - Add a toggle switch:
     ```javascript
     document.querySelector('.theme-toggle').addEventListener('change', (e) => {
       document.body.dataset.theme = e.target.checked ? 'light' : 'dark';
       localStorage.setItem('theme', document.body.dataset.theme);
     });
     // Load saved theme
     document.body.dataset.theme = localStorage.getItem('theme') || 'dark';
     ```

---

### 11. Additional Considerations
- **Validations**: Reject negative reps, weights >1000kg, or illogical inputs via frontend and backend checks.
- **Performance**: Optimize STS suggestion generation to run in <500ms (e.g., limit combinations or precompute).
- **Security**: Encrypt sensitive data (e.g., logs) with AES-256 and ensure GDPR/CCPA compliance with data deletion options.
- **Testing**: Write unit tests for 1RM calculations and integration tests for the full workout flow.

---

## Final Notes
- **Prioritization**: Start with authentication, exercise management, and progression schemes as core features.
- **Documentation**: Update README or inline comments with new feature details.
- **Git Workflow**: Commit changes per feature for clarity (e.g., `git commit -m "Add user authentication"`).

These steps provide a clear, technical roadmap to implement the missing PRD features, ensuring the app meets all specified requirements.