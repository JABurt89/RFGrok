Data Encryption for Logs

In server/utils.ts, import crypto and define:
typescript
Copy
import { createCipheriv, createDecipheriv, randomBytes } from "crypto";
const key = Buffer.from(process.env.ENCRYPTION_KEY!, "hex");
const algorithm = "aes-256-cbc";
export function encrypt(data: string): string { /* ... */ }
export function decrypt(data: string): string { /* ... */ }
In server/storage.ts, update workout log methods to:
Encrypt sets before insert:
typescript
Copy
const encryptedSets = encrypt(JSON.stringify(insertWorkoutLog.sets));
Decrypt sets after retrieval:
typescript
Copy
sets: JSON.parse(decrypt(workoutLog.sets as string))
Set ENCRYPTION_KEY in the environment.
Conflict Resolution for Offline Syncing

In client/src/hooks/useApi.ts:
Add state:
typescript
Copy
const [conflict, setConflict] = useState<{ local: WorkoutLog; cloud: WorkoutLog } | null>(null);
In syncWorkoutLog, fetch cloud log, compare timestamps, and call setConflict if local is newer.
Implement resolveConflict(choice: "local" | "cloud") to PATCH the selected log and clear conflict.
In WorkoutLogger.tsx, render an AlertDialog for conflict resolution with actions calling resolveConflict.
Optimistic Updates for Logging

In client/src/components/workout-logger.tsx:
Use useMutation and useQueryClient from @tanstack/react-query.
In onMutate:
Cancel queries and update cache with a temporary log (e.g., using Date.now() as id).
In onError:
Roll back to previous cache using context.
In onSettled:
Invalidate queries and trigger onComplete.
Error Handling Consistency

In client/src/lib/queryClient.ts, wrap API calls in try/catch:
On error, trigger useToast with title "Error" and the error message, then rethrow.
Modularize Progression Logic

Create shared/progression.ts:
Define ProgressionScheme interface and STSProgression class with methods:
typescript
Copy
calculate1RM(sets: { reps: number; weight: number }[], extraSetReps?: number): number { /* ... */ }
getNextSuggestion(last1RM: number, increment: number): { sets: number; reps: number; weight: number }[] { /* ... */ }
Replace in-line progression logic with instances of STSProgression.
Unit Tests for Critical Logic

Install Jest:
bash
Copy
npm install --save-dev jest @types/jest ts-jest
Create shared/progression.test.ts with test cases (e.g., 1RM calculation).
Add "test": "jest" script in package.json.
Rate-Limiting for Security

Install: npm install express-rate-limit
In server/auth.ts, import rateLimit and define:
typescript
Copy
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: "Too many login attempts, please try again later",
});
Apply loginLimiter middleware to /api/login.
Account Deletion for Compliance

In server/routes.ts, add DELETE endpoint:
typescript
Copy
app.delete("/api/user", async (req, res) => {
  if (!req.isAuthenticated()) return res.sendStatus(401);
  await storage.deleteUser(req.user.id);
  req.logout(err => err ? next(err) : res.sendStatus(204));
});
In server/storage.ts, implement:
typescript
Copy
async deleteUser(id: number): Promise<void> {
  await db.transaction(async (tx) => {
    await tx.delete(workoutLogs).where(eq(workoutLogs.userId, id));
    await tx.delete(workoutDays).where(eq(workoutDays.userId, id));
    await tx.delete(exercises).where(eq(exercises.userId, id));
    await tx.delete(users).where(eq(users.id, id));
  });
}
In the client UI (e.g., home-page.tsx), add a button to call the DELETE endpoint.
UI Responsiveness

In client/src/components/ui/sidebar.tsx:
Import useMobile and conditionally render sidebar:
typescript
Copy
const isMobile = useMobile();
<div className={`sidebar ${isMobile ? "hidden md:block" : "block"}`}>â€¦</div>
In home-page.tsx, implement theme toggle:
Use useState to track theme and a button to toggle between "dark" and "light", updating document.documentElement.classList accordingly.