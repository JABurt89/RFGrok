1. Simplify and Update Progression Logic (shared/progression.ts)
Objective: Ensure each progression scheme returns a single, clear suggestion to streamline the UI and eliminate selection complexity.
Modifications:
Update the getNextSuggestion method in all progression classes (STSProgression, DoubleProgression, RPTTopSetDependent, RPTIndividualProgression) to return a single ProgressionSuggestion instead of an array.
For STSProgression, select the suggestion with the smallest 1RM increase over the last logged 1RM.
Ensure the suggestion includes all necessary fields for display (e.g., sets, reps, weight, and for RPT schemes, setWeights and repTargets).
Example for RPTTopSetDependent:

tsx

Collapse

Wrap

Copy
getNextSuggestion(lastWeight: number, increment: number, consecutiveFailures: number = 0): ProgressionSuggestion {
  const baseWeight = lastWeight || increment;
  let topSetWeight = consecutiveFailures >= 2 ? Math.max(increment, baseWeight * 0.9) : baseWeight;
  const setWeights = this.calculateSetWeights(topSetWeight);
  return {
    sets: this.sets,
    reps: this.minReps,
    weight: topSetWeight,
    setWeights,
    repTargets: Array(this.sets).fill({ min: this.minReps, max: this.maxReps })
  };
}
For STSProgression:
Modify the existing logic to sort suggestions by calculated1RM and return only the first one:
tsx

Collapse

Wrap

Copy
getNextSuggestion(last1RM: number, increment: number): ProgressionSuggestion {
  const suggestions: ProgressionSuggestion[] = [];
  for (let sets = this.minSets; sets <= this.maxSets; sets++) {
    for (let reps = this.minReps; reps <= this.maxReps; reps++) {
      const baseW = last1RM / ((1 + 0.025 * reps) * (1 + 0.025 * (sets - 1)));
      const roundedWeight = Number((Math.round(baseW / increment) * increment).toFixed(2));
      const calculated1RM = this.calculate1RM(Array(sets).fill({ reps, weight: roundedWeight }));
      if (calculated1RM > last1RM) {
        suggestions.push({ sets, reps, weight: roundedWeight, calculated1RM });
      }
    }
  }
  const sorted = suggestions.sort((a, b) => a.calculated1RM! - b.calculated1RM!);
  return sorted[0] || { sets: this.minSets, reps: this.minReps, weight: increment };
}