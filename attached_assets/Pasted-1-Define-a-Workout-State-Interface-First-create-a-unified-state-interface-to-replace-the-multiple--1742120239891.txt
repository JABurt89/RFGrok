1. Define a Workout State Interface
First, create a unified state interface to replace the multiple state variables:
typescriptCopy// workout-state.ts
export interface WorkoutState {
  isWorkoutActive: boolean;
  currentSet: number;
  loggedSets: Array<{
    reps: number;
    weight: number;
    timestamp: string;
    isFailure?: boolean;
    exceededMax?: boolean;
  }>;
  restTimer: number | null;
  selectedSuggestion: any | null;
  extraSetReps: number | null;
  workoutLogId: number | null;
  isEditing: boolean;
  editWeight: number | null;
  editReps: number | null;
  showRepsInput: boolean;
}

export const initialWorkoutState: WorkoutState = {
  isWorkoutActive: false,
  currentSet: 0,
  loggedSets: [],
  restTimer: null,
  selectedSuggestion: null,
  extraSetReps: null,
  workoutLogId: null,
  isEditing: false,
  editWeight: null,
  editReps: null,
  showRepsInput: false
};
2. Create Action Types
Define all possible actions that can modify the workout state:
typescriptCopy// workout-actions.ts
export type WorkoutAction =
  | { type: 'START_WORKOUT'; payload: { suggestion: any } }
  | { type: 'COMPLETE_SET'; payload: { weight: number; reps: number } }
  | { type: 'FAIL_SET'; payload: { weight: number; completedReps: number } }
  | { type: 'LOG_REPS'; payload: { reps: number; exceededMax?: boolean } }
  | { type: 'START_EDITING' }
  | { type: 'CANCEL_EDITING' }
  | { type: 'UPDATE_EDIT_WEIGHT'; payload: number }
  | { type: 'UPDATE_EDIT_REPS'; payload: number }
  | { type: 'TOGGLE_REPS_INPUT'; payload: boolean }
  | { type: 'SET_WORKOUT_LOG_ID'; payload: number }
  | { type: 'UPDATE_REST_TIMER'; payload: number | null }
  | { type: 'TICK_REST_TIMER' }
  | { type: 'LOG_EXTRA_SET'; payload: number }
  | { type: 'RESET_WORKOUT' };
3. Implement the Reducer Function
Create a reducer function that handles all state transitions:
typescriptCopy// workout-reducer.ts
import { WorkoutState, initialWorkoutState } from './workout-state';
import { WorkoutAction } from './workout-actions';

export function workoutReducer(state: WorkoutState, action: WorkoutAction): WorkoutState {
  switch (action.type) {
    case 'START_WORKOUT':
      return {
        ...state,
        isWorkoutActive: true,
        selectedSuggestion: action.payload.suggestion,
        currentSet: 0,
        loggedSets: []
      };
      
    case 'COMPLETE_SET':
      const newSets = [...state.loggedSets, {
        weight: action.payload.weight,
        reps: action.payload.reps,
        timestamp: new Date().toISOString(),
        isFailure: false
      }];
      
      return {
        ...state,
        loggedSets: newSets,
        currentSet: state.currentSet + 1,
        restTimer: state.currentSet + 1 >= state.selectedSuggestion?.sets 
          ? null 
          : state.selectedSuggestion?.parameters?.restBetweenSets || 60,
        isEditing: false,
        editWeight: null,
        editReps: null
      };
      
    case 'FAIL_SET':
      return {
        ...state,
        loggedSets: [...state.loggedSets, {
          weight: action.payload.weight,
          reps: action.payload.completedReps,
          timestamp: new Date().toISOString(),
          isFailure: true
        }],
        currentSet: state.currentSet + 1,
        restTimer: state.selectedSuggestion?.parameters?.restBetweenSets || 60,
        showRepsInput: false
      };
      
    case 'LOG_REPS':
      const target = getCurrentSetTarget(state);
      if (!target) return state;
      
      return {
        ...state,
        loggedSets: [...state.loggedSets, {
          weight: state.editWeight ?? target.weight,
          reps: action.payload.reps,
          timestamp: new Date().toISOString(),
          isFailure: false,
          exceededMax: action.payload.exceededMax
        }],
        currentSet: state.currentSet + 1,
        restTimer: state.currentSet + 1 >= state.selectedSuggestion?.sets 
          ? null 
          : state.selectedSuggestion?.parameters?.restBetweenSets || 60,
        showRepsInput: false,
        isEditing: false,
        editWeight: null,
        editReps: null
      };
      
    case 'START_EDITING':
      const currentTarget = getCurrentSetTarget(state);
      if (!currentTarget) return state;
      
      return {
        ...state,
        isEditing: true,
        editWeight: currentTarget.weight,
        editReps: currentTarget.reps
      };
      
    case 'CANCEL_EDITING':
      return {
        ...state,
        isEditing: false,
        editWeight: null,
        editReps: null
      };
      
    case 'UPDATE_EDIT_WEIGHT':
      return {
        ...state,
        editWeight: action.payload
      };
      
    case 'UPDATE_EDIT_REPS':
      return {
        ...state,
        editReps: action.payload
      };
      
    case 'TOGGLE_REPS_INPUT':
      return {
        ...state,
        showRepsInput: action.payload
      };
      
    case 'SET_WORKOUT_LOG_ID':
      return {
        ...state,
        workoutLogId: action.payload
      };
      
    case 'UPDATE_REST_TIMER':
      return {
        ...state,
        restTimer: action.payload
      };
      
    case 'TICK_REST_TIMER':
      if (state.restTimer === null || state.restTimer <= 0) return state;
      
      return {
        ...state,
        restTimer: state.restTimer - 1
      };
      
    case 'LOG_EXTRA_SET':
      return {
        ...state,
        extraSetReps: action.payload
      };
      
    case 'RESET_WORKOUT':
      return initialWorkoutState;
      
    default:
      return state;
  }
}

// Helper function to get current set target
function getCurrentSetTarget(state: WorkoutState) {
  if (!state.selectedSuggestion) return null;
  
  // This is a simplified version - you would need to implement
  // the same logic as in your current getCurrentSetTarget function
  return {
    weight: state.selectedSuggestion.weight,
    reps: state.selectedSuggestion.reps
  };
}
4. Create Custom Hook for Workout Logic
Create a custom hook to encapsulate workout logic:
typescriptCopy// use-workout.ts
import { useReducer, useEffect } from 'react';
import { workoutReducer } from './workout-reducer';
import { initialWorkoutState } from './workout-state';
import { useQuery, useMutation } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';

export function useWorkout(
  exerciseId: number,
  workoutDayId: number,
  parameters: any,
  onComplete: () => void
) {
  const [state, dispatch] = useReducer(workoutReducer, initialWorkoutState);
  const { user } = useAuth();
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Fetch workout suggestion
  const { data: suggestions, isLoading, error: queryError } = useQuery({
    queryKey: ['/api/workout-suggestion', exerciseId],
    queryFn: async () => {
      if (!user) throw new Error("Not authenticated");
      const url = new URL('/api/workout-suggestion', window.location.origin);
      url.searchParams.append('exerciseId', exerciseId.toString());
      const response = await apiRequest("GET", url.toString());
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: "Failed to parse error response" }));
        throw new Error(errorData.error || "Failed to fetch workout suggestion");
      }
      return response.json();
    },
    enabled: Boolean(exerciseId) && Boolean(user),
  });

  // Create workout log mutation
  const createLogMutation = useMutation({
    mutationFn: async () => {
      if (!user || !state.selectedSuggestion) throw new Error("Invalid workout setup");
      const response = await apiRequest("POST", "/api/workout-logs", {
        userId: user.id,
        date: new Date().toISOString(),
        sets: [{
          exerciseId,
          sets: [],
          parameters: parameters,
        }],
        isComplete: false
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: "Failed to parse error response" }));
        throw new Error(errorData.error || "Failed to create workout log");
      }
      return response.json();
    },
    onSuccess: (data) => {
      dispatch({ type: 'SET_WORKOUT_LOG_ID', payload: data.id });
      queryClient.invalidateQueries({ queryKey: ["/api/workout-logs"] });
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Handle starting a workout
  const handleStartWorkout = async (suggestion: any) => {
    try {
      dispatch({ type: 'START_WORKOUT', payload: { suggestion } });
      await createLogMutation.mutateAsync();
      
      // For RPT workouts, immediately show rep selection
      if (parameters.scheme === "RPT Individual" || parameters.scheme === "RPT Top-Set") {
        dispatch({ type: 'TOGGLE_REPS_INPUT', payload: true });
      }
    } catch (error) {
      console.error("Error starting workout:", error);
    }
  };

  // Handle completing a set
  const handleSetComplete = () => {
    if (!state.selectedSuggestion) return;

    const target = getCurrentSetTarget();
    if (!target) return;

    // For RPT workouts, always show rep selection UI
    if (parameters.scheme === "RPT Individual" || parameters.scheme === "RPT Top-Set") {
      dispatch({ type: 'TOGGLE_REPS_INPUT', payload: true });
      return;
    }

    // For other schemes like STS, directly log the set
    const weight = state.editWeight ?? target.weight;
    const reps = state.editReps ?? target.reps;

    dispatch({ 
      type: 'COMPLETE_SET', 
      payload: { weight, reps } 
    });

    // Don't call onComplete() here for STS - wait for extra set
    if (state.currentSet + 1 >= state.selectedSuggestion.sets && parameters.scheme !== "STS") {
      onComplete();
    }
  };

  // Rest timer effect
  useEffect(() => {
    let interval: number;
    if (state.restTimer !== null && state.restTimer > 0) {
      interval = window.setInterval(() => {
        dispatch({ type: 'TICK_REST_TIMER' });
      }, 1000);

      // Play sound when timer reaches 0
      if (state.restTimer === 1) {
        new Audio('/chime.mp3').play().catch(console.error);
      }
    }
    return () => window.clearInterval(interval);
  }, [state.restTimer]);

  // Auto-show rep selection for RPT workouts
  useEffect(() => {
    if (parameters.scheme === "RPT Individual" || parameters.scheme === "RPT Top-Set") {
      // Show dialog when workout starts
      if (state.isWorkoutActive && state.currentSet === 0 && !state.showRepsInput) {
        dispatch({ type: 'TOGGLE_REPS_INPUT', payload: true });
      }
      // Show dialog after rest timer ends
      if (state.restTimer === 0 && state.currentSet < state.selectedSuggestion?.sets && !state.showRepsInput) {
        dispatch({ type: 'TOGGLE_REPS_INPUT', payload: true });
      }
    }
  }, [parameters.scheme, state.isWorkoutActive, state.currentSet, state.restTimer, state.showRepsInput, state.selectedSuggestion]);

  // Add other necessary methods

  return {
    state,
    dispatch,
    suggestions,
    isLoading,
    queryError,
    handleStartWorkout,
    handleSetComplete,
    // Add other handlers
  };
}
5. Refactor WorkoutLogger Component
Use the custom hook in your WorkoutLogger component:
typescriptCopy// workout-logger.tsx
export default function WorkoutLogger({ exerciseId, workoutDayId, parameters, onComplete, totalExercises = 3 }: WorkoutLoggerProps) {
  const { 
    state, 
    dispatch, 
    suggestions, 
    isLoading, 
    queryError, 
    handleStartWorkout, 
    handleSetComplete 
  } = useWorkout(exerciseId, workoutDayId, parameters, onComplete);

  const handleRepSelection = (reps: number, exceededMax: boolean = false) => {
    dispatch({ type: 'LOG_REPS', payload: { reps, exceededMax } });
    
    // Check if we've completed all sets
    if (state.currentSet + 1 >= state.selectedSuggestion?.sets) {
      onComplete(); // Move to next exercise
    }
  };

  const handleSetFailed = (completedReps: number) => {
    if (!state.selectedSuggestion) return;
    const target = getCurrentSetTarget();
    if (!target) return;
    
    dispatch({ 
      type: 'FAIL_SET', 
      payload: { 
        weight: target.weight, 
        completedReps 
      } 
    });
  };

  const handleEditToggle = () => {
    if (state.isEditing) {
      dispatch({ type: 'CANCEL_EDITING' });
    } else {
      dispatch({ type: 'START_EDITING' });
    }
  };

  // Render component using state from useWorkout hook
  // (The rest of your component remains similar but uses the state and dispatch)
}
6. Create Scheme-Specific Logic
For each workout scheme, create a separate file with scheme-specific logic:
typescriptCopy// rpt-workout-logic.ts
import { WorkoutState } from './workout-state';
import { WorkoutAction } from './workout-actions';

export function getRPTSetTarget(state: WorkoutState, parameters: any, currentSet: number) {
  if (!state.selectedSuggestion) return null;
  
  if (parameters.scheme === "RPT Top-Set") {
    const dropPercentage = parameters.dropPercentages[currentSet] || 0;
    const baseWeight = state.selectedSuggestion.weight;
    const weight = baseWeight * (1 - dropPercentage / 100);
    return {
      weight: Math.round(weight * 2) / 2,
      reps: parameters.maxReps